---
title: "散列表"
date: 2019-07-01T21:57:17+08:00
tags:
categories:
- hash
---

用算术操作将键转化为数组的索引来访问数组中的键值对
- 散列函数： 将键转化为数组的一个索引
- 处理碰撞冲突
    1. 拉链法
    2. 开放地址法
        - 线性探测法

<!--more-->

# 散列函数
评价散列函数好坏的指标：
1. 易于计算（高效性）
2. 均匀分布（均匀性）
3. 等价的键必然产生相等的散列值（一致性）

散列函数跟键的类型有关：
1. 正整数
    - 除留余数法，除数M(即数组的大小)应为素数
2. 浮点数
    - 将键乘以M并四舍五入得到一个[0, M-1]的索引值（键的高位起的作用更大）
    - 将键表示为二进制再使用除留余数法
3. 字符串
    - 将字符串作为大整数， 除留余数法
        - `charAt()` 会返回一个非负16位整数（ASCII值）
        - 如果N比任何字符的值都大，相当于将字符串当做一个N位R进制值，并将它除以M取余

            ```c
            int hash = 0
            for(int i = 0; i < s.length; i ++)
                hash = (R * hash + s.charAt(i)) % M
            ```
    - Horner法： 用N次乘法，加法和取余来计算一个字符串的散列值（R足够小，不造成溢出）
4. 组合键
    - 将多个部分组合起来，如Date, 通常选择适当的M来省去括号内的%M计算，如R为31，则M也为31

        ```c++
        int hash = ((((day * R) + month) % M )* R + year ) % M
        ```

# 散列表对象
- 方法：
    1. `hashCode()`: 返回一个32bit整数（默认返回对象的内存地址）
        - 将 `hashCode()` 的返回值转化为一个数组索引值

            ```
            int hash(key x)
            {
                return (x.hashCode() & 0x7FFFFFFF ) % u
            }
            ```
        - 如果 `hashCode()` 很难计算，可以将其保存起来
    2. `equals()`
        - 如果 `a.equals(b)` 为 `true`, 则 `a.hashCode() == b.hashCode()` 也为true,反之则不然

# 存储键值
## 分离链接法--拉链法
> 将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该该元素的索引的键值对

- 基本思想： 选择足够大的M，使得所有链表都尽可能短以保证高效的查找
- 查找步骤：
    1. 根据散列值找到对应的链表
    2. 沿着链表顺序查找相应的链
- 散列表大小：
    1. 若M较大，则查找时间会快
    2. 若M较小，则空间占用小
- 动态调整散列表大小
    - `if (N > 0 & N <= M/8) reSize(M/2)`

## 开放定址散列法--线性探测法
> 利用空位解决冲突

- 基本思想： 与其将内存用作链表，不如将他们作为在散列表中的空元素，这些空元素可以作为查找结束的标志
- 查找： 当碰撞发生时，我们直接检查散列表中的下一个位置，将索引值+1
    1. 命中，该位置的链表和被查找的键相同
    2. 未命中，键为空（该位置没有链）
    3. 继续查找，该位置的键和被查找的键不同，直到找打该键或者遇到一个空元素或再次到达该索引
- 动态调整散列表大小
    - `insert`: `N >= M/2 reSize(2*M)`
    - `delete`: `(N>0 & N <= M/8) reSize(M/2)`
