[{"uri":"/posts/alog_time","tags":[],"content":" 排序 插入排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 插入排序  | N | N^2 | N | 1 | T ||  希尔 排序  | NlogN | NlogN | * | 1 | F ||  二分 查找 排序  | N | N^2 | N | 1 | T | 选择 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 选择 排序  | N^2 | N^2 | N^2 | 1 | T ||  堆排序  | NlogN | NlogN | NlogN | 1 | T | 交换 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  冒泡排序  | N^2 | N^2 | N | 1 | T ||  快速 排序  | NlogN | N^2 | NlogN | NlogN | F | 其他 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  归并 排序  | NlogN | NlogN | NlogN | N | T ||  基数排序  | d(n+r) | d(n+r) | d(n+r) | (n+r) | T | 查找 |  排序 方法  |  复杂度  || --- | --- ||  二分 查找  | logN || BST | logN |","title":" 常用 排序 / 查找 算法 时间 复杂度 ","oriTitle":"常用排序/查找算法时间复杂度"},{"uri":"/posts/hugo_usage","tags":[],"content":"Grammarwarning    {{}}This is a warning    {{}} 折叠 /Read More 引用     >This is a reference    >       def a():    >           print(b)    > 表格 | head1 | head2 || --- | --- || key1 | v1 || key2 | v2 |Commandgulp serve : liveload servergulp build: generate public files to /docsgulp lunr: generate index file for searchTemplate Grammer Linkshttp://www.g-var.com/posts/translation/hugo/hugo-22-hugo-template-functions/","title":"Hugo Usage","oriTitle":"Hugo Usage"},{"uri":"/posts/persistence_and_serialization","tags":[],"content":" 持久 化 和 序列化 都 是 对象 服务 持久 化 是 解决 如何 长时间 保存 数据 的 问题 序列化 是 解决 对象 传输 的 问题 对象 的 持久 化 前提 是 对象 的 序列化 。 持久 化 持久 化 是 将 数据 或者 对象 从 内存 中 存储 到 可以 永久 保存 （ 或者 保存 一定 时间 ） 到 存储设备 中 ， 如 磁盘 ， 磁带 ， 常用 的 持久 化 方式 有      保存 到 磁盘 文件 中 , xml 文件      保存 到 数据库          关系 型 数据库      保存 到 Session 中 也 是 一中 持久 化 方式 持久 化 主要 解决 由于 内存 掉电 易 失 而 不能 保存 数据 的 问题 。 持久 化 是 将 程序 数据 在 持久 状态 和 瞬时 状态 间 转换 的 机制 序列化 序列化 是 将 数据 或 对象 转化成 字节 流 ， 从而 易于 传输 ， 常用 的 序列化 方式 有     json    yaml>  数据 的 输入输出 就 像 水 一样 从 一个 地方 流 到 另 一个 地方 ， 所有 叫做 数据流 >  数据流 的 用途 就是 输入输出 序列化 是 为了 解决 对象 的 传输 问题 ， 传输 可以 在线 程 之间 、 进程 之间 、 内存 外存 之间 、 主机 之间 进行 ","title":" 持久 化 与 序列化 的 区别 与 联系 ","oriTitle":"持久化与序列化的区别与联系"},{"uri":"/posts/rpc_vs_rest_vs_graphql","tags":[],"content":" 衡量 API 好坏 的 标准 （5C+DV）：Coupling， 耦合 性 Chattiness/performance(network latency, overload),  网络 负载 Client complexity,  客户端 复杂度 Congative complexity,  是否 易于 理解 Caching,  是否 能够 cacheDiscoverability,  自 发现 ,  自省 (introspect)     如果 没用过 API,  从 哪里 开始 使用      应该 调 哪 一个 API( 如 多 版本 情况 )Versioning，  版本 管理 如何 选择 API 需要 考虑 的 问题 谁 使用 这个 APIAPI 设计 是 为了 解决 什么 事情 RPCRemote Procedure Call: call the function on another server 调用 在 远程 服务器 上 的 方法 基本 元素 ： functionSchemaGet   /listConversationsGet   /listMessagesPost  /sendMessageGet   /getAuthorGet   /checkMessageStatusGet   /listConversationV2Advantages 简单明了 ， 容易 理解 ，HTTP 协议 在 这里 时 透明 的 ， 就 像 调用 一个 函数 一样 增加 一个 API 只要 增加 一个 函数 就 好 了 lightweight payloads 高性能 ， 网络 负载 低 ， 吞吐量 大 ， 适合 公司 内部 微 服务 之间 的 大量 消息 传输 Dis 客户端 和 服务端 耦合 性 高 ， 调用 API 需要 知道 其 背后 函数 的 逻辑 因此 会 泄露 代码 细节 服务 的 可 发现 低 ， 作为 一个 新手 不 知道 去 哪 找 API, 如何 找 下 一个 API， API 具体 做 什么 事 函数 爆炸  function explosion， 如果 已有 的 函数 不能 满足 需求 ， 如 现有 的  listConversation  不能 得到 更 多 的 消息 ， 需要 创建 一个  v2 版 ， 每 一个 功能 都 要 写 一个 新 API,  造成 冗余 ， 难以 维护 Scenario 适合 公司 内部 微 服务 之间 的 大量 消息 传输 面向 命令 ， 事务 ， 如 转账 ， 创建 ， 登录 RESTRepresentational State Transfer  表现 层 状态 转移 架构 式 的 设计 ， 为 了解 耦 客户端 与 服务端 而 设计 基本 元素 ： Resource 定义      使用 URI 定义 一个 资源      使用 HTTP 的 GET/POST/PUT/DELETE 来 控制 资源 的 增删 改 查     HATEOAS:  从 一个 API 能够 找到 所有 其他 相关 的 API        HyperTest As The Engine Of Application State         返回 的 结果 中 加入 对 其他 元素 的 link        metadata     无 状态     CacheSchemaGet /messages{    \"href\": \"/messages\",    \"desc\": \"...\",    \"count\": 5,    \"objects\": [        {            \"href\": \"/messages/1\",            \"value\": \"message 1\"            \"author: {                \"value\": \"author1\",                \"href\": \"/message/1/author\"            }    ]        }}Advantages 解 耦 客户端 与 服务器端 自省 性 ，  在 总 入口 增加 所有 可以 访问 的 API 的 list, metadata 不用 专门 写 文档 ，API 本身 即 文档 API 可以 演化 ， 为 一个 资源 增加 属性 不用 创建 新 的 API,  可 直接 升级 reuse http verbs/cache/content 缓存 已 请求 的 信息 ， 因为 每次 都 是 返回 资源 的 所有 信息 ， 所以 可以 在 有效期 内 可以 再 利用 DisChatty  如果 想 获取 一条 消息 的 的 作者 的 信息 ， 则 要 至少 请求 两次 ， 会 增加 网络 开销 payloads 比较 大 ， 返回 一些 不 需要 的 信息 ,  增加 网络 负载 如果 网络 条件 不好 ， 会 增加 网络 负担 ScenarioManagement API,  以 资源 / 对象 为 模型 ， 如 管理 用户 面对 各种各样 不同 客户端 ， 如 开放 给 公众 ， 此时 需要 良好 的 文档 和 自省 能力 需要 拥有 自省 （ 自 发现 性 ） 能力 GraphQL 回 你 想要 面向 查询 Advantage 只 返回 你 所 想要 的 ， 所以 网络 开销 低 typed schema 适合 图形 数据结构 ， 如 人脉关系 Dis 复杂 每次 请求 的 东西 可能 不 一样 ， 不能 做 缓存 版本 管理 现在 使用 太 早 ， 市场 支持 不够 Scenario 图形 数据结构 为 由于 payloads 过 大 造成 网络 负载 过 高 ， 带宽 过 大 从而 延迟 过 高 而 做 优化 每个 客户端 对 payloads 的 需求 很 不 一样 Linkhttps://www.youtube.com/watch?v=IvsANO0qZEg&t=111s","title":"How to Design a Good API","oriTitle":"How to Design a Good API"}]