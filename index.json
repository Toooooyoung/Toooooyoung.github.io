[{"uri":"/posts/alog_time","tags":[],"content":" 排序 插入排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 插入排序  | N | N^2 | N | 1 | T ||  希尔 排序  | NlogN | NlogN | * | 1 | F ||  二分 查找 排序  | N | N^2 | N | 1 | T | 选择 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 选择 排序  | N^2 | N^2 | N^2 | 1 | T ||  堆排序  | NlogN | NlogN | NlogN | 1 | T | 交换 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  冒泡排序  | N^2 | N^2 | N | 1 | T ||  快速 排序  | NlogN | N^2 | NlogN | NlogN | F | 其他 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  归并 排序  | NlogN | NlogN | NlogN | N | T ||  基数排序  | d(n+r) | d(n+r) | d(n+r) | (n+r) | T | 查找 |  排序 方法  |  复杂度  || --- | --- ||  二分 查找  | logN || BST | logN |","title":" 常用 排序 / 查找 算法 时间 复杂度 ","oriTitle":"常用排序/查找算法时间复杂度"},{"uri":"/posts/hugo_usage","tags":[],"content":"Grammarwarning    {{}}This is a warning    {{}} 折叠 /Read More 引用     >This is a reference    >       def a():    >           print(b)    > 表格 | head1 | head2 || --- | --- || key1 | v1 || key2 | v2 |Commandgulp serve : liveload servergulp build: generate public files to /docsgulp lunr: generate index file for searchTemplate Grammer Linkshttp://www.g-var.com/posts/translation/hugo/hugo-22-hugo-template-functions/","title":"Hugo Usage","oriTitle":"Hugo Usage"},{"uri":"/posts/persistence_and_serialization","tags":[],"content":" 持久 化 和 序列化 都 是 对象 服务 ,  持久 化 是 解决 如何 长时间 保存 数据 的 问题 ， 序列化 是 解决 对象 传输 的 问题 。 对象 的 持久 化 前提 是 对象 的 序列化 。 持久 化 持久 化 是 将 数据 或者 对象 从 内存 中 存储 到 可以 永久 保存 （ 或者 保存 一定 时间 ） 到 存储设备 中 ， 如 磁盘 ， 磁带 ， 常用 的 持久 化 方式 有      保存 到 磁盘 文件 中 , xml 文件      保存 到 数据库          关系 型 数据库      保存 到 Session 中 也 是 一中 持久 化 方式 持久 化 主要 解决 由于 内存 掉电 易 失 而 不能 保存 数据 的 问题 。 持久 化 是 将 程序 数据 在 持久 状态 和 瞬时 状态 间 转换 的 机制 序列化 序列化 是 将 数据 或 对象 转化成 字节 流 ， 从而 易于 传输 ， 常用 的 序列化 方式 有     json    yaml>  数据 的 输入输出 就 像 水 一样 从 一个 地方 流 到 另 一个 地方 ， 所有 叫做 数据流 >  数据流 的 用途 就是 输入输出 序列化 是 为了 解决 对象 的 传输 问题 ， 传输 可以 在线 程 之间 、 进程 之间 、 内存 外存 之间 、 主机 之间 进行 ","title":" 持久 化 与 序列化 的 区别 与 联系 ","oriTitle":"持久化与序列化的区别与联系"},{"uri":"/posts/rpc_vs_rest_vs_graphql","tags":[],"content":" 当 设计 一个 新 的 API 模式 时 一般 有 以下几点 需要 进行 权衡 考虑 ：coupling， 耦合 性 chattiness/performance(network latency, overload),  网络 负载 client complexity,  客户端 复杂度 congative complexity,  是否 易于 理解 caching,  是否 能够 cachediscoverability,  自 发现 ， 由 一 推 多 versioning，  版本 管理 ","title":"How to Design a Good API","oriTitle":"How to Design a Good API"}]