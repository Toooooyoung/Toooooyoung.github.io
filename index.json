[{"uri":"/posts/alog_time","tags":[],"content":" 排序 插入排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 插入排序  | N | N^2 | N | 1 | T ||  希尔 排序  | NlogN | NlogN | * | 1 | F ||  二分 查找 排序  | N | N^2 | N | 1 | T | 选择 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  直接 选择 排序  | N^2 | N^2 | N^2 | 1 | T ||  堆排序  | NlogN | NlogN | NlogN | 1 | T | 交换 排序 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  冒泡排序  | N^2 | N^2 | N | 1 | T ||  快速 排序  | NlogN | N^2 | NlogN | NlogN | F | 其他 |  排序 方法  |  平均  |  最 坏  |  最好  |  空间 复杂度  |  稳定  || --- | --- | --- | --- | --- | --- ||  归并 排序  | NlogN | NlogN | NlogN | N | T ||  基数排序  | d(n+r) | d(n+r) | d(n+r) | (n+r) | T | 查找 |  排序 方法  |  复杂度  || --- | --- ||  二分 查找  | logN || BST | logN |","title":" 常用 排序 / 查找 算法 时间 复杂度 ","oriTitle":"常用排序/查找算法时间复杂度"},{"uri":"/posts/hash","tags":[],"content":" 用 算术 操作 将 键 转化 为 数组 的 索引 来 访问 数组 中 的 键值 对 散 列 函数 ：  将 键 转化 为 数组 的 一个 索引 处理 碰撞 冲突      拉链 法      开放 地址 法          线性 探测 法 散 列 函数 评价 散 列 函数 好坏 的 指标 ： 易于 计算 （ 高效性 ） 均匀分布 （ 均匀 性 ） 等价 的 键 必然 产生 相等 的 散 列 值 （ 一致性 ） 散 列 函数 跟 键 的 类型 有关 ： 正整数      除 留 余数 法 ， 除数 M( 即 数组 的 大小 ) 应为 素数 浮点数      将 键 乘以 M 并 四舍五入 得到 一个 [0, M-1] 的 索引 值 （ 键 的 高位 起 的 作用 更 大 ）     将 键 表示 为 二进制 再 使用 除 留 余数 法 字符串      将 字符串 作为 大 整数 ，  除 留 余数 法         charAt()  会 返回 一个 非 负 16 位 整数 （ASCII 值 ）         如果 N 比 任何 字符 的 值 都 大 ， 相当于 将 字符串 当做 一个 N 位 R 进制 值 ， 并 将 它 除以 M 取 余                         int hash = 0            for(int i = 0; i   将 大小 为 M 的 数组 中 的 每个 元素 指向 一条 链表 ， 链表 中 的 每个 结点 都 存储 了 散 列 值 为 该 该 元素 的 索引 的 键值 对 基本 思想 ：  选择 足够 大 的 M， 使得 所有 链表 都 尽可能 短 以 保证 高效 的 查找 查找 步骤 ：     根据 散 列 值 找到 对应 的 链表      沿着 链表 顺序 查找 相应 的 链 散 列表 大小 ：     若 M 较大 ， 则 查找时间 会 快      若 M 较 小 ， 则 空间 占用 小 动态 调整 散 列表 大小     `if (N > 0 & N   利用 空位 解决 冲突 基本 思想 ：  与其 将 内存 用作 链表 ， 不如 将 他们 作为 在 散 列表 中 的 空 元素 ， 这些 空 元素 可以 作为 查找 结束 的 标志 查找 ：  当 碰撞 发生 时 ， 我们 直接 检查 散 列表 中 的 下 一个 位置 ， 将 索引 值 +1     命中 ， 该 位置 的 链表 和 被 查找 的 键 相同      未 命中 ， 键 为 空 （ 该 位置 没有 链 ）     继续 查找 ， 该 位置 的 键 和 被 查找 的 键 不同 ， 直到 找 打 该 键 或者 遇到 一个 空 元素 或 再次 到达 该 索引 动态 调整 散 列表 大小     insert: N >= M/2 reSize(2*M)    delete: (N>0 & N <= M/8) reSize(M/2)","title":" 散 列表 ","oriTitle":"散列表"},{"uri":"/posts/hugo_usage","tags":[],"content":"Grammarwarning    {{}}This is a warning    {{}} 折叠 /Read More 引用     >This is a reference    >       def a():    >           print(b)    > 表格 | head1 | head2 || --- | --- || key1 | v1 || key2 | v2 |Commandgulp serve : liveload servergulp build: generate public files to /docsgulp lunr: generate index file for searchTemplate Grammer Linkshttp://www.g-var.com/posts/translation/hugo/hugo-22-hugo-template-functions/","title":"Hugo Usage","oriTitle":"Hugo Usage"},{"uri":"/posts/persistence_and_serialization","tags":[],"content":" 持久 化 和 序列化 都 是 对象 服务 持久 化 是 解决 如何 长时间 保存 数据 的 问题 序列化 是 解决 对象 传输 的 问题 对象 的 持久 化 前提 是 对象 的 序列化 。 持久 化 持久 化 是 将 数据 或者 对象 从 内存 中 存储 到 可以 永久 保存 （ 或者 保存 一定 时间 ） 到 存储设备 中 ， 如 磁盘 ， 磁带 ， 常用 的 持久 化 方式 有      保存 到 磁盘 文件 中 , xml 文件      保存 到 数据库          关系 型 数据库      保存 到 Session 中 也 是 一中 持久 化 方式 持久 化 主要 解决 由于 内存 掉电 易 失 而 不能 保存 数据 的 问题 。 持久 化 是 将 程序 数据 在 持久 状态 和 瞬时 状态 间 转换 的 机制 序列化 序列化 是 将 数据 或 对象 转化成 字节 流 ， 从而 易于 传输 ， 常用 的 序列化 方式 有     json    yaml>  数据 的 输入输出 就 像 水 一样 从 一个 地方 流 到 另 一个 地方 ， 所有 叫做 数据流 >  数据流 的 用途 就是 输入输出 序列化 是 为了 解决 对象 的 传输 问题 ， 传输 可以 在线 程 之间 、 进程 之间 、 内存 外存 之间 、 主机 之间 进行 ","title":" 持久 化 与 序列化 的 区别 与 联系 ","oriTitle":"持久化与序列化的区别与联系"},{"uri":"/posts/rpc_vs_rest_vs_graphql","tags":[],"content":" 衡量 API 好坏 的 标准 （5C+DV）：Coupling， 耦合 性 Chattiness/performance(network latency, overload),  网络 负载 Client complexity,  客户端 复杂度 Congative complexity,  是否 易于 理解 Caching,  是否 能够 cacheDiscoverability,  自 发现 ,  自省 (introspect)     如果 没用过 API,  从 哪里 开始 使用      应该 调 哪 一个 API( 如 多 版本 情况 )Versioning，  版本 管理 如何 选择 API 需要 考虑 的 问题 谁 使用 这个 APIAPI 设计 是 为了 解决 什么 事情 RPCRemote Procedure Call: call the function on another server 调用 在 远程 服务器 上 的 方法 基本 元素 ： functionSchemaGet   /listConversationsGet   /listMessagesPost  /sendMessageGet   /getAuthorGet   /checkMessageStatusGet   /listConversationV2Advantages 简单明了 ， 容易 理解 ，HTTP 协议 在 这里 时 透明 的 ， 就 像 调用 一个 函数 一样 增加 一个 API 只要 增加 一个 函数 就 好 了 lightweight payloads 高性能 ， 网络 负载 低 ， 吞吐量 大 ， 适合 公司 内部 微 服务 之间 的 大量 消息 传输 Dis 客户端 和 服务端 耦合 性 高 ， 调用 API 需要 知道 其 背后 函数 的 逻辑 因此 会 泄露 代码 细节 服务 的 可 发现 低 ， 作为 一个 新手 不 知道 去 哪 找 API, 如何 找 下 一个 API， API 具体 做 什么 事 函数 爆炸  function explosion， 如果 已有 的 函数 不能 满足 需求 ， 如 现有 的  listConversation  不能 得到 更 多 的 消息 ， 需要 创建 一个  v2 版 ， 每 一个 功能 都 要 写 一个 新 API,  造成 冗余 ， 难以 维护 Scenario 适合 公司 内部 微 服务 之间 的 大量 消息 传输 面向 命令 ， 事务 ， 如 转账 ， 创建 ， 登录 RESTRepresentational State Transfer  表现 层 状态 转移 架构 式 的 设计 ， 为 了解 耦 客户端 与 服务端 而 设计 基本 元素 ： Resource 定义      使用 URI 定义 一个 资源      使用 HTTP 的 GET/POST/PUT/DELETE 来 控制 资源 的 增删 改 查     HATEOAS:  从 一个 API 能够 找到 所有 其他 相关 的 API        HyperTest As The Engine Of Application State         返回 的 结果 中 加入 对 其他 元素 的 link        metadata     无 状态     CacheSchemaGet /messages{    \"href\": \"/messages\",    \"desc\": \"...\",    \"count\": 5,    \"objects\": [        {            \"href\": \"/messages/1\",            \"value\": \"message 1\"            \"author: {                \"value\": \"author1\",                \"href\": \"/message/1/author\"            }    ]        }}Advantages 解 耦 客户端 与 服务器端 自省 性 ，  在 总 入口 增加 所有 可以 访问 的 API 的 list, metadata 不用 专门 写 文档 ，API 本身 即 文档 API 可以 演化 ， 为 一个 资源 增加 属性 不用 创建 新 的 API,  可 直接 升级 reuse http verbs/cache/content 缓存 已 请求 的 信息 ， 因为 每次 都 是 返回 资源 的 所有 信息 ， 所以 可以 在 有效期 内 可以 再 利用 DisChatty  如果 想 获取 一条 消息 的 的 作者 的 信息 ， 则 要 至少 请求 两次 ， 会 增加 网络 开销 payloads 比较 大 ， 返回 一些 不 需要 的 信息 ,  增加 网络 负载 如果 网络 条件 不好 ， 会 增加 网络 负担 ScenarioManagement API,  以 资源 / 对象 为 模型 ， 如 管理 用户 面对 各种各样 不同 客户端 ， 如 开放 给 公众 ， 此时 需要 良好 的 文档 和 自省 能力 需要 拥有 自省 （ 自 发现 性 ） 能力 GraphQL 回 你 想要 面向 查询 Advantage 只 返回 你 所 想要 的 ， 所以 网络 开销 低 typed schema 适合 图形 数据结构 ， 如 人脉关系 Dis 复杂 每次 请求 的 东西 可能 不 一样 ， 不能 做 缓存 版本 管理 现在 使用 太 早 ， 市场 支持 不够 Scenario 图形 数据结构 为 由于 payloads 过 大 造成 网络 负载 过 高 ， 带宽 过 大 从而 延迟 过 高 而 做 优化 每个 客户端 对 payloads 的 需求 很 不 一样 Linkhttps://www.youtube.com/watch?v=IvsANO0qZEg&t=111s","title":"How to Design a Good API","oriTitle":"How to Design a Good API"}]